{"remainingRequest":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\babel-loader\\lib\\index.js??ref--6-1!C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\src\\ui\\public\\visualize\\spy.js","dependencies":[{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\src\\ui\\public\\visualize\\spy.js","mtime":1525446439301},{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1493198456000},{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\babel-loader\\lib\\index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _spy_modes = require('ui/registry/spy_modes');\n\nvar _modules = require('ui/modules');\n\nvar _spy = require('ui/visualize/spy.html');\n\nvar _spy2 = _interopRequireDefault(_spy);\n\nvar _persisted_state = require('ui/persisted_state');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_modules.uiModules.get('app/visualize').directive('visualizeSpy', function (Private, $compile, $timeout) {\n\n  var spyModes = Private(_spy_modes.SpyModesRegistryProvider);\n\n  return {\n    restrict: 'E',\n    template: _spy2.default,\n    scope: {\n      vis: '<',\n      searchSource: '<',\n      uiState: '<',\n      visElement: '<'\n    },\n    link: function link($scope, $el) {\n\n      // If no uiState has been passed, create a local one for this spy.\n      if (!$scope.uiState) $scope.uiState = new _persisted_state.PersistedState({});\n\n      var currentSpy = void 0;\n      var defaultModeName = void 0;\n\n      var $container = $el.find('[data-spy-content-container]');\n\n      $scope.modes = [];\n\n      $scope.currentMode = null;\n      $scope.maximizedSpy = false;\n      $scope.forceMaximized = false;\n\n      function checkForcedMaximized() {\n        $timeout(function () {\n          if ($scope.visElement && $scope.currentMode && $scope.visElement.height() < 180) {\n            $scope.forceMaximized = true;\n          } else {\n            $scope.forceMaximized = false;\n          }\n        });\n      }\n\n      checkForcedMaximized();\n\n      /**\n       * Filter for modes that should actually be active for this visualization.\n       * This will call the showMode method of the mode, pass it the vis object.\n       * Depending on whether or not that returns a truthy value, it will be shown\n       * or not. If the method is not present, the mode will always be shown.\n       */\n      function filterModes() {\n        $scope.modes = spyModes.inOrder.filter(function (mode) {\n          return mode.showMode ? mode.showMode($scope.vis) : true;\n        });\n        defaultModeName = $scope.modes.length > 0 ? $scope.modes[0].name : null;\n      }\n\n      filterModes();\n      $scope.$watch('vis', filterModes);\n\n      function syncFromUiState() {\n        $scope.currentMode = $scope.uiState.get('spy.mode.name');\n        $scope.maximizedSpy = $scope.uiState.get('spy.mode.fill');\n      }\n\n      /**\n       * Write our current state into the uiState.\n       * This will write the name and fill (maximized) into the uiState\n       * if a panel is opened (currentMode is set) or it will otherwise\n       * remove the spy key from the uiState.\n       */\n      function updateUiState() {\n        if ($scope.currentMode) {\n          $scope.uiState.set('spy.mode', {\n            name: $scope.currentMode,\n            fill: $scope.maximizedSpy\n          });\n        } else {\n          $scope.uiState.set('spy', null);\n        }\n      }\n\n      // Initially sync the panel state from the uiState.\n      syncFromUiState();\n\n      // Whenever the uiState changes, update the settings from it.\n      $scope.uiState.on('change', syncFromUiState);\n      $scope.$on('$destroy', function () {\n        return $scope.uiState.off('change', syncFromUiState);\n      });\n\n      $scope.setSpyMode = function setSpyMode(modeName) {\n        $scope.currentMode = modeName;\n        updateUiState();\n        $scope.$emit('render');\n      };\n\n      $scope.toggleDisplay = function () {\n        // If the spy panel is already shown (a currentMode is set),\n        // close the panel by setting the name to null, otherwise open the\n        // panel (i.e. set it to the default mode name).\n        if ($scope.currentMode) {\n          $scope.setSpyMode(null);\n          $scope.forceMaximized = false;\n        } else {\n          $scope.setSpyMode(defaultModeName);\n          checkForcedMaximized();\n        }\n      };\n\n      /**\n       * Should we currently show the spy panel. True if a currentMode has been set.\n       */\n      $scope.shouldShowSpyPanel = function () {\n        return !!$scope.currentMode;\n      };\n\n      /**\n       * Toggle maximized state of spy panel and update the UI state.\n       */\n      $scope.toggleMaximize = function () {\n        $scope.maximizedSpy = !$scope.maximizedSpy;\n        updateUiState();\n      };\n\n      /**\n       * Whenever the maximized state changes, we also need to toggle the class\n       * of the visualization.\n       */\n      $scope.$watchMulti(['maximizedSpy', 'forceMaximized'], function () {\n        $scope.visElement.toggleClass('spy-only', $scope.maximizedSpy || $scope.forceMaximized);\n      });\n\n      /**\n       * Watch for changes of the currentMode. Whenever it changes, we render\n       * the new mode into the template. Therefore we remove the previously rendered\n       * mode (if existing) and compile and bind the template of the new mode.\n       */\n      $scope.$watch('currentMode', function (mode, prevMode) {\n        if (mode === prevMode && currentSpy && currentSpy.mode === mode) {\n          // When the mode hasn't changed and we have already rendered it, return.\n          return;\n        }\n\n        var newMode = spyModes.byName[mode];\n\n        if (currentSpy) {\n          // If we already have a spy loaded, remove that HTML element and\n          // destroy the previous Angular scope.\n          currentSpy.$container.remove();\n          currentSpy.$scope.$destroy();\n          currentSpy = null;\n        }\n\n        // If we want haven't specified a new mode we won't do anything further.\n        if (!newMode) {\n          // Reset the forced maximized flag if we are about to close the panel.\n          $scope.forceMaximized = false;\n          return;\n        }\n\n        var contentScope = $scope.$new();\n        var contentContainer = (0, _jquery2.default)('<div class=\"visualize-spy-content\">');\n        contentContainer.append($compile(newMode.template)(contentScope));\n\n        $container.append(contentContainer);\n\n        currentSpy = {\n          $scope: contentScope,\n          $container: contentContainer,\n          mode: mode\n        };\n\n        newMode.link && newMode.link(currentSpy.$scope, currentSpy.$element);\n      });\n    }\n  };\n});",null]}