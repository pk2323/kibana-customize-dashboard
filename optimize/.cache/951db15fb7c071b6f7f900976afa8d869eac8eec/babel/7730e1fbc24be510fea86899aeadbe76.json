{"remainingRequest":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\babel-loader\\lib\\index.js??ref--6-1!C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\src\\core_plugins\\vega\\public\\data_model\\vega_parser.js","dependencies":[{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\src\\core_plugins\\vega\\public\\data_model\\vega_parser.js","mtime":1525446285466},{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1493198456000},{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\babel-loader\\lib\\index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VegaParser = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _vegaLib = require('vega-lib');\n\nvar vega = _interopRequireWildcard(_vegaLib);\n\nvar _vegaLite = require('vega-lite');\n\nvar vegaLite = _interopRequireWildcard(_vegaLite);\n\nvar _vegaSchemaUrlParser = require('vega-schema-url-parser');\n\nvar _vegaSchemaUrlParser2 = _interopRequireDefault(_vegaSchemaUrlParser);\n\nvar _compareVersions = require('compare-versions');\n\nvar _compareVersions2 = _interopRequireDefault(_compareVersions);\n\nvar _es_query_parser = require('./es_query_parser');\n\nvar _hjson = require('hjson');\n\nvar _hjson2 = _interopRequireDefault(_hjson);\n\nvar _utils = require('./utils');\n\nvar _ems_file_parser = require('./ems_file_parser');\n\nvar _url_parser = require('./url_parser');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DEFAULT_SCHEMA = 'https://vega.github.io/schema/vega/v3.0.json';\n\nvar locToDirMap = {\n  left: 'row-reverse',\n  right: 'row',\n  top: 'column-reverse',\n  bottom: 'column'\n};\n\n// If there is no \"%type%\" parameter, use this parser\nvar DEFAULT_PARSER = 'elasticsearch';\n\nvar VegaParser = exports.VegaParser = function () {\n  function VegaParser(spec, searchCache, timeCache, dashboardContext, serviceSettings) {\n    _classCallCheck(this, VegaParser);\n\n    this.spec = spec;\n    this.hideWarnings = false;\n    this.error = undefined;\n    this.warnings = [];\n\n    var onWarn = this._onWarning.bind(this);\n    this._urlParsers = {\n      elasticsearch: new _es_query_parser.EsQueryParser(timeCache, searchCache, dashboardContext, onWarn),\n      emsfile: new _ems_file_parser.EmsFileParser(serviceSettings),\n      url: new _url_parser.UrlParser(onWarn)\n    };\n  }\n\n  _createClass(VegaParser, [{\n    key: 'parseAsync',\n    value: function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return this._parseAsync();\n\n              case 3:\n                _context.next = 8;\n                break;\n\n              case 5:\n                _context.prev = 5;\n                _context.t0 = _context['catch'](0);\n\n                // if we reject current promise, it will use the standard Kibana error handling\n                this.error = _utils.Utils.formatErrorToStr(_context.t0);\n\n              case 8:\n                return _context.abrupt('return', this);\n\n              case 9:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 5]]);\n      }));\n\n      function parseAsync() {\n        return _ref.apply(this, arguments);\n      }\n\n      return parseAsync;\n    }()\n  }, {\n    key: '_parseAsync',\n    value: function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.isVegaLite !== undefined)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error();\n\n              case 2:\n\n                if (typeof this.spec === 'string') {\n                  this.spec = _hjson2.default.parse(this.spec, { legacyRoot: false });\n                }\n\n                if (_lodash2.default.isPlainObject(this.spec)) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                throw new Error('Invalid Vega spec');\n\n              case 5:\n                this.isVegaLite = this._parseSchema();\n                this.useHover = !this.isVegaLite;\n\n                this._config = this._parseConfig();\n                this.hideWarnings = !!this._config.hideWarnings;\n                this.useMap = this._config.type === 'map';\n                this.renderer = this._config.renderer === 'svg' ? 'svg' : 'canvas';\n\n                this._setDefaultColors();\n                this._parseControlPlacement(this._config);\n                if (this.useMap) {\n                  this.mapConfig = this._parseMapConfig();\n                } else if (this.spec.autosize === undefined) {\n                  // Default autosize should be fit, unless it's a map (leaflet-vega handles that)\n                  this.spec.autosize = { type: 'fit', contains: 'padding' };\n                }\n\n                _context2.next = 16;\n                return this._resolveDataUrls();\n\n              case 16:\n\n                if (this.isVegaLite) {\n                  this._compileVegaLite();\n                }\n\n                this._calcSizing();\n\n              case 18:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _parseAsync() {\n        return _ref2.apply(this, arguments);\n      }\n\n      return _parseAsync;\n    }()\n\n    /**\n     * Convert VegaLite to Vega spec\n     * @private\n     */\n\n  }, {\n    key: '_compileVegaLite',\n    value: function _compileVegaLite() {\n      if (this.useMap) {\n        throw new Error('\"_map\" configuration is not compatible with vega-lite spec');\n      }\n      this.vlspec = this.spec;\n\n      var logger = vega.logger(vega.Warn);\n      logger.warn = this._onWarning.bind(this);\n      this.spec = vegaLite.compile(this.vlspec, logger).spec;\n    }\n\n    /**\n     * Process graph size and padding\n     * @private\n     */\n\n  }, {\n    key: '_calcSizing',\n    value: function _calcSizing() {\n      this.useResize = !this.useMap && (this.spec.autosize === 'fit' || this.spec.autosize.type === 'fit');\n\n      // Padding is not included in the width/height by default\n      this.paddingWidth = 0;\n      this.paddingHeight = 0;\n      if (this.useResize && this.spec.padding && this.spec.autosize.contains !== 'padding') {\n        if (_typeof(this.spec.padding) === 'object') {\n          this.paddingWidth += (+this.spec.padding.left || 0) + (+this.spec.padding.right || 0);\n          this.paddingHeight += (+this.spec.padding.top || 0) + (+this.spec.padding.bottom || 0);\n        } else {\n          this.paddingWidth += 2 * (+this.spec.padding || 0);\n          this.paddingHeight += 2 * (+this.spec.padding || 0);\n        }\n      }\n\n      if (this.useResize && (this.spec.width || this.spec.height)) {\n        if (this.isVegaLite) {\n          delete this.spec.width;\n          delete this.spec.height;\n        } else {\n          this._onWarning('The \\'width\\' and \\'height\\' params are ignored with autosize=fit');\n        }\n      }\n    }\n\n    /**\n     * Calculate container-direction CSS property for binding placement\n     * @private\n     */\n\n  }, {\n    key: '_parseControlPlacement',\n    value: function _parseControlPlacement() {\n      this.containerDir = locToDirMap[this._config.controlsLocation];\n      if (this.containerDir === undefined) {\n        if (this._config.controlsLocation === undefined) {\n          this.containerDir = 'column';\n        } else {\n          throw new Error('Unrecognized controlsLocation value. Expecting one of [\"' + locToDirMap.keys().join('\", \"') + '\"]');\n        }\n      }\n      var dir = this._config.controlsDirection;\n      if (dir !== undefined && dir !== 'horizontal' && dir !== 'vertical') {\n        throw new Error('Unrecognized dir value. Expecting one of [\"horizontal\", \"vertical\"]');\n      }\n      this.controlsDir = dir === 'horizontal' ? 'row' : 'column';\n    }\n\n    /**\n     * Parse {config: kibana: {...}} portion of the Vega spec (or root-level _hostConfig for backward compat)\n     * @returns {object} kibana config\n     * @private\n     */\n\n  }, {\n    key: '_parseConfig',\n    value: function _parseConfig() {\n      var result = void 0;\n      if (this.spec._hostConfig !== undefined) {\n        result = this.spec._hostConfig;\n        delete this.spec._hostConfig;\n        if (!_lodash2.default.isPlainObject(result)) {\n          throw new Error('If present, _hostConfig must be an object');\n        }\n        this._onWarning('_hostConfig has been deprecated. Use config.kibana instead.');\n      }\n      if (_lodash2.default.isPlainObject(this.spec.config) && this.spec.config.kibana !== undefined) {\n        result = this.spec.config.kibana;\n        delete this.spec.config.kibana;\n        if (!_lodash2.default.isPlainObject(result)) {\n          throw new Error('If present, config.kibana must be an object');\n        }\n      }\n      return result || {};\n    }\n\n    /**\n     * Parse map-specific configuration\n     * @returns {{mapStyle: *|string, delayRepaint: boolean, latitude: number, longitude: number, zoom, minZoom, maxZoom, zoomControl: *|boolean, maxBounds: *}}\n     * @private\n     */\n\n  }, {\n    key: '_parseMapConfig',\n    value: function _parseMapConfig() {\n      var _this = this;\n\n      var res = {\n        delayRepaint: this._config.delayRepaint === undefined ? true : this._config.delayRepaint\n      };\n\n      var validate = function validate(name, isZoom) {\n        var val = _this._config[name];\n        if (val !== undefined) {\n          var parsed = Number.parseFloat(val);\n          if (Number.isFinite(parsed) && (!isZoom || parsed >= 0 && parsed <= 30)) {\n            res[name] = parsed;\n            return;\n          }\n          _this._onWarning('config.kibana.' + name + ' is not valid');\n        }\n        if (!isZoom) res[name] = 0;\n      };\n\n      validate('latitude', false);\n      validate('longitude', false);\n      validate('zoom', true);\n      validate('minZoom', true);\n      validate('maxZoom', true);\n\n      // `false` is a valid value\n      res.mapStyle = this._config.mapStyle === undefined ? 'default' : this._config.mapStyle;\n      if (res.mapStyle !== 'default' && res.mapStyle !== false) {\n        this._onWarning('config.kibana.mapStyle may either be false or \"default\"');\n        res.mapStyle = 'default';\n      }\n\n      var zoomControl = this._config.zoomControl;\n      if (zoomControl === undefined) {\n        res.zoomControl = true;\n      } else if (typeof zoomControl !== 'boolean') {\n        this._onWarning('config.kibana.zoomControl must be a boolean value');\n        res.zoomControl = true;\n      } else {\n        res.zoomControl = zoomControl;\n      }\n\n      var maxBounds = this._config.maxBounds;\n      if (maxBounds !== undefined) {\n        if (!Array.isArray(maxBounds) || maxBounds.length !== 4 || !maxBounds.every(function (v) {\n          return typeof v === 'number' && Number.isFinite(v);\n        })) {\n          this._onWarning('config.kibana.maxBounds must be an array with four numbers');\n        } else {\n          res.maxBounds = maxBounds;\n        }\n      }\n\n      return res;\n    }\n\n    /**\n     * Parse Vega schema element\n     * @returns {boolean} is this a VegaLite schema?\n     * @private\n     */\n\n  }, {\n    key: '_parseSchema',\n    value: function _parseSchema() {\n      if (!this.spec.$schema) {\n        this._onWarning('The input spec does not specify a \"$schema\", defaulting to \"' + DEFAULT_SCHEMA + '\"');\n        this.spec.$schema = DEFAULT_SCHEMA;\n      }\n\n      var schema = (0, _vegaSchemaUrlParser2.default)(this.spec.$schema);\n      var isVegaLite = schema.library === 'vega-lite';\n      var libVersion = isVegaLite ? vegaLite.version : vega.version;\n\n      if ((0, _compareVersions2.default)(schema.version, libVersion) > 0) {\n        this._onWarning('The input spec uses ' + schema.library + ' ' + schema.version + ', but ' + ('current version of ' + schema.library + ' is ' + libVersion + '.'));\n      }\n\n      return isVegaLite;\n    }\n\n    /**\n     * Replace all instances of ES requests with raw values.\n     * Also handle any other type of url: {type: xxx, ...}\n     * @private\n     */\n\n  }, {\n    key: '_resolveDataUrls',\n    value: function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n        var _this2 = this;\n\n        var pending, pendingParsers;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                pending = {};\n\n\n                this._findObjectDataUrls(this.spec, function (obj) {\n                  var url = obj.url;\n                  delete obj.url;\n                  var type = url['%type%'];\n                  delete url['%type%'];\n                  if (type === undefined) {\n                    type = DEFAULT_PARSER;\n                  }\n\n                  var parser = _this2._urlParsers[type];\n                  if (parser === undefined) {\n                    throw new Error('url: {\"%type%\": \"' + type + '\"} is not supported');\n                  }\n\n                  var pendingArr = pending[type];\n                  if (pendingArr === undefined) {\n                    pending[type] = pendingArr = [];\n                  }\n\n                  pendingArr.push(parser.parseUrl(obj, url));\n                });\n\n                pendingParsers = Object.keys(pending);\n\n                if (!(pendingParsers.length > 0)) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                _context3.next = 6;\n                return Promise.all(pendingParsers.map(function (type) {\n                  return _this2._urlParsers[type].populateData(pending[type]);\n                }));\n\n              case 6:\n              case 'end':\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _resolveDataUrls() {\n        return _ref3.apply(this, arguments);\n      }\n\n      return _resolveDataUrls;\n    }()\n\n    /**\n     * Recursively find and callback every instance of the data.url as an object\n     * @param {*} obj current location in the object tree\n     * @param {function({object})} onFind Call this function for all url objects\n     * @param {string} [key] field name of the current object\n     * @private\n     */\n\n  }, {\n    key: '_findObjectDataUrls',\n    value: function _findObjectDataUrls(obj, onFind, key) {\n      if (Array.isArray(obj)) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = obj[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var elem = _step.value;\n\n            this._findObjectDataUrls(elem, onFind, key);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else if (_lodash2.default.isPlainObject(obj)) {\n        if (key === 'data' && _lodash2.default.isPlainObject(obj.url)) {\n          // Assume that any  \"data\": {\"url\": {...}}  is a request for data\n          if (obj.values !== undefined || obj.source !== undefined) {\n            throw new Error('Data must not have more than one of \"url\", \"values\", and \"source\"');\n          }\n          onFind(obj);\n        } else {\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = Object.keys(obj)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var k = _step2.value;\n\n              this._findObjectDataUrls(obj[k], onFind, k);\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Inject default colors into the spec.config\n     * @private\n     */\n\n  }, {\n    key: '_setDefaultColors',\n    value: function _setDefaultColors() {\n      // Default category coloring to the Elastic color scheme\n      this._setDefaultValue({ scheme: 'elastic' }, 'config', 'range', 'category');\n\n      // Set default single color to match other Kibana visualizations\n      var defaultColor = '#00A69B';\n      if (this.isVegaLite) {\n        // Vega-Lite: set default color, works for fill and strike --  config: { mark:  { color: '#00A69B' }}\n        this._setDefaultValue(defaultColor, 'config', 'mark', 'color');\n      } else {\n        // Vega - global mark has very strange behavior, must customize each mark type individually\n        // https://github.com/vega/vega/issues/1083\n        // Don't set defaults if spec.config.mark.color or fill are set\n        if (!this.spec.config.mark || this.spec.config.mark.color === undefined && this.spec.config.mark.fill === undefined) {\n          this._setDefaultValue(defaultColor, 'config', 'arc', 'fill');\n          this._setDefaultValue(defaultColor, 'config', 'area', 'fill');\n          this._setDefaultValue(defaultColor, 'config', 'line', 'stroke');\n          this._setDefaultValue(defaultColor, 'config', 'path', 'stroke');\n          this._setDefaultValue(defaultColor, 'config', 'rect', 'fill');\n          this._setDefaultValue(defaultColor, 'config', 'rule', 'stroke');\n          this._setDefaultValue(defaultColor, 'config', 'shape', 'stroke');\n          this._setDefaultValue(defaultColor, 'config', 'symbol', 'fill');\n          this._setDefaultValue(defaultColor, 'config', 'trail', 'fill');\n        }\n      }\n    }\n\n    /**\n     * Set default value if it doesn't exist.\n     * Given an object, and an array of fields, ensure that obj.fld1.fld2. ... .fldN is set to value if it doesn't exist.\n     * @param {*} value\n     * @param {string} fields\n     * @private\n     */\n\n  }, {\n    key: '_setDefaultValue',\n    value: function _setDefaultValue(value) {\n      var o = this.spec;\n\n      for (var _len = arguments.length, fields = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        fields[_key - 1] = arguments[_key];\n      }\n\n      for (var i = 0; i < fields.length - 1; i++) {\n        var field = fields[i];\n        var subObj = o[field];\n        if (subObj === undefined) {\n          o[field] = {};\n        } else if (!_lodash2.default.isPlainObject(subObj)) {\n          return;\n        }\n        o = o[field];\n      }\n      var lastField = fields[fields.length - 1];\n      if (o[lastField] === undefined) {\n        o[lastField] = value;\n      }\n    }\n\n    /**\n     * Add a warning to the warnings array\n     * @private\n     */\n\n  }, {\n    key: '_onWarning',\n    value: function _onWarning() {\n      if (!this.hideWarnings) {\n        this.warnings.push(_utils.Utils.formatWarningToStr.apply(_utils.Utils, arguments));\n      }\n    }\n  }]);\n\n  return VegaParser;\n}();",null]}