{"remainingRequest":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\babel-loader\\lib\\index.js??ref--6-1!C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\src\\ui\\public\\visualize\\visualize.js","dependencies":[{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\src\\ui\\public\\visualize\\visualize.js","mtime":1525446439488},{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1493198456000},{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\babel-loader\\lib\\index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _modules = require('ui/modules');\n\nvar _state_monitor_factory = require('ui/state_management/state_monitor_factory');\n\nvar _visualize = require('ui/visualize/visualize.html');\n\nvar _visualize2 = _interopRequireDefault(_visualize);\n\nvar _vis_request_handlers = require('ui/registry/vis_request_handlers');\n\nvar _vis_response_handlers = require('ui/registry/vis_response_handlers');\n\nrequire('angular-sanitize');\n\nrequire('./visualization');\n\nrequire('./visualization_editor');\n\nvar _query_filter = require('ui/filter_bar/query_filter');\n\nvar _resize_checker = require('ui/resize_checker');\n\nvar _elasticsearch_errors = require('../elasticsearch_errors');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n_modules.uiModules.get('kibana/directive', ['ngSanitize']).directive('visualize', function ($timeout, Notifier, Private, timefilter, getAppState, Promise) {\n  var notify = new Notifier({ location: 'Visualize' });\n  var requestHandlers = Private(_vis_request_handlers.VisRequestHandlersRegistryProvider);\n  var responseHandlers = Private(_vis_response_handlers.VisResponseHandlersRegistryProvider);\n  var queryFilter = Private(_query_filter.FilterBarQueryFilterProvider);\n  var ResizeChecker = Private(_resize_checker.ResizeCheckerProvider);\n\n  function getHandler(from, name) {\n    if (typeof name === 'function') return name;\n    return from.find(function (handler) {\n      return handler.name === name;\n    }).handler;\n  }\n\n  return {\n    restrict: 'E',\n    scope: {\n      showSpyPanel: '=?',\n      editorMode: '=?',\n      savedObj: '=?',\n      appState: '=?',\n      uiState: '=?',\n      timeRange: '=?'\n    },\n    template: _visualize2.default,\n    link: function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee($scope, $el) {\n        var destroyed, resizeChecker, searchSource, requestHandler, responseHandler, handleVisUpdate, reload, handleQueryUpdate, stateMonitor;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                destroyed = false;\n\n                if ($scope.savedObj) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw 'saved object was not provided to <visualize> directive';\n\n              case 3:\n                if (!$scope.appState) $scope.appState = getAppState();\n\n                resizeChecker = new ResizeChecker($el, { disabled: true });\n\n                $timeout(function () {\n                  // We give the visualize one digest cycle time to actually render before\n                  // we start tracking its size. If we don't do that, we cause a double\n                  // initial rendering in editor mode.\n                  resizeChecker.enable();\n                });\n\n                $scope.vis = $scope.savedObj.vis;\n\n                // Set the passed in uiState to the vis object. uiState reference should never be changed\n                if (!$scope.uiState) $scope.uiState = $scope.vis.getUiState();else $scope.vis._setUiState($scope.uiState);\n\n                $scope.vis.description = $scope.savedObj.description;\n\n                if ($scope.timeRange) {\n                  $scope.vis.getTimeRange = function () {\n                    return $scope.timeRange;\n                  };\n\n                  searchSource = $scope.savedObj.searchSource;\n\n                  searchSource.filter(function () {\n                    return timefilter.get(searchSource.index(), $scope.timeRange);\n                  });\n\n                  // we're only adding one range filter against the timeFieldName to ensure\n                  // that our filter is the only one applied and override the global filters.\n                  // this does rely on the \"implementation detail\" that filters are added first\n                  // on the leaf SearchSource and subsequently on the parents\n                  searchSource.addFilterPredicate(function (filter, state) {\n                    if (!filter.range) {\n                      return true;\n                    }\n\n                    var timeFieldName = searchSource.index().timeFieldName;\n                    if (!timeFieldName) {\n                      return true;\n                    }\n\n                    return !(state.filters || []).find(function (f) {\n                      return f.range && f.range[timeFieldName];\n                    });\n                  });\n                }\n\n                $scope.editorMode = $scope.editorMode || false;\n                $scope.vis.editorMode = $scope.editorMode;\n\n                requestHandler = getHandler(requestHandlers, $scope.vis.type.requestHandler);\n                responseHandler = getHandler(responseHandlers, $scope.vis.type.responseHandler);\n\n\n                $scope.fetch = _lodash2.default.debounce(function () {\n                  // If destroyed == true the scope has already been destroyed, while this method\n                  // was still waiting for its debounce, in this case we don't want to start\n                  // fetching new data and rendering.\n                  if (!$scope.vis.initialized || !$scope.savedObj || destroyed) return;\n                  // searchSource is only there for courier request handler\n                  requestHandler($scope.vis, $scope.appState, $scope.uiState, queryFilter, $scope.savedObj.searchSource).then(function (requestHandlerResponse) {\n\n                    //No need to call the response handler when there have been no data nor has been there changes\n                    //in the vis-state (response handler does not depend on uiStat\n                    var canSkipResponseHandler = $scope.previousRequestHandlerResponse && $scope.previousRequestHandlerResponse === requestHandlerResponse && $scope.previousVisState && _lodash2.default.isEqual($scope.previousVisState, $scope.vis.getState());\n\n                    $scope.previousVisState = $scope.vis.getState();\n                    $scope.previousRequestHandlerResponse = requestHandlerResponse;\n                    return canSkipResponseHandler ? $scope.visData : Promise.resolve(responseHandler($scope.vis, requestHandlerResponse));\n                  }, function (e) {\n                    $scope.savedObj.searchSource.cancelQueued();\n                    $scope.vis.requestError = e;\n                    if ((0, _elasticsearch_errors.isTermSizeZeroError)(e)) {\n                      return notify.error('Your visualization (\\'' + $scope.vis.title + '\\') has an error: it has a term ' + 'aggregation with a size of 0. Please set it to a number greater than 0 to resolve ' + 'the error.');\n                    }\n                    notify.error(e);\n                  }).then(function (resp) {\n                    $scope.visData = resp;\n                    $scope.$apply();\n                    $scope.$broadcast('render');\n                    return resp;\n                  });\n                }, 100);\n\n                //todo: clean this one up as well\n\n                handleVisUpdate = function handleVisUpdate() {\n                  if ($scope.editorMode) {\n                    $scope.appState.vis = $scope.vis.getState();\n                    $scope.appState.save();\n                  } else {\n                    $scope.fetch();\n                  }\n                };\n\n                $scope.vis.on('update', handleVisUpdate);\n\n                reload = function reload() {\n                  $scope.vis.reload = true;\n                  $scope.fetch();\n                };\n\n                $scope.vis.on('reload', reload);\n                // auto reload will trigger this event\n                $scope.$on('courier:searchRefresh', reload);\n                // dashboard will fire fetch event when it wants to refresh\n                $scope.$on('fetch', reload);\n\n                handleQueryUpdate = function handleQueryUpdate() {\n                  $scope.fetch();\n                };\n\n                queryFilter.on('update', handleQueryUpdate);\n\n                if ($scope.appState) {\n                  stateMonitor = _state_monitor_factory.stateMonitorFactory.create($scope.appState);\n\n                  stateMonitor.onChange(function (status, type, keys) {\n                    if (keys[0] === 'vis') {\n                      if ($scope.appState.vis) $scope.vis.setState($scope.appState.vis);\n                      $scope.fetch();\n                    }\n                    if ($scope.vis.type.requiresSearch && ['query', 'filters'].includes(keys[0])) {\n                      $scope.fetch();\n                    }\n                  });\n\n                  $scope.$on('$destroy', function () {\n                    stateMonitor.destroy();\n                  });\n                }\n\n                // Listen on uiState changes to start fetching new data again.\n                // Some visualizations might need different data depending on their uiState,\n                // thus we need to retrigger. The request handler should take care about\n                // checking if anything changed, that actually require a new fetch or return\n                // cached data otherwise.\n                $scope.uiState.on('change', $scope.fetch);\n                resizeChecker.on('resize', $scope.fetch);\n\n                // visualize needs to know about timeFilter\n                $scope.$listen(timefilter, 'fetch', $scope.fetch);\n\n                $scope.$on('$destroy', function () {\n                  destroyed = true;\n                  $scope.vis.removeListener('update', handleVisUpdate);\n                  queryFilter.off('update', handleQueryUpdate);\n                  $scope.uiState.off('change', $scope.fetch);\n                  resizeChecker.destroy();\n                });\n\n                $scope.$watch('vis.initialized', $scope.fetch);\n\n                $scope.fetch();\n\n              case 30:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function link(_x, _x2) {\n        return _ref.apply(this, arguments);\n      }\n\n      return link;\n    }()\n  };\n});",null]}