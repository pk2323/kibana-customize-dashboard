{"remainingRequest":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\babel-loader\\lib\\index.js??ref--6-1!C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\src\\core_plugins\\console\\public\\tests\\src\\integration_tests.js","dependencies":[{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\src\\core_plugins\\console\\public\\tests\\src\\integration_tests.js","mtime":1525446212453},{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1493198456000},{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\babel-loader\\lib\\index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _input = require('../../src/input');\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar input = void 0;\nvar kb = require('../../src/kb');\nvar mappings = require('../../src/mappings');\nvar $ = require('jquery');\n\nvar _window$QUnit = window.QUnit,\n    _module = _window$QUnit.module,\n    ok = _window$QUnit.ok,\n    asyncTest = _window$QUnit.asyncTest,\n    deepEqual = _window$QUnit.deepEqual,\n    equal = _window$QUnit.equal,\n    start = _window$QUnit.start;\n\n\n_module(\"Integration\", {\n  setup: function setup() {\n    input = (0, _input.initializeInput)($('#editor'), $('#editor_actions'), $('#copy_as_curl'), null);\n    input.$el.show();\n    input.autocomplete._test.removeChangeListener();\n  },\n  teardown: function teardown() {\n    input.$el.hide();\n    input.autocomplete._test.addChangeListener();\n  }\n});\n\nfunction process_context_test(data, mapping, kb_schemes, request_line, test) {\n  asyncTest(test.name, function () {\n\n    console.debug(\"starting test \" + test.name);\n\n    var rowOffset = 0; // add one for the extra method line\n    var editorValue = data;\n    if (request_line != null) {\n      if (data != null) {\n        editorValue = request_line + \"\\n\" + data;\n        rowOffset = 1;\n      } else {\n        editorValue = request_line;\n      }\n    }\n\n    test.cursor.row += rowOffset;\n\n    mappings.clear();\n    mappings.loadMappings(mapping);\n    var json = {};\n    json[test.name] = kb_schemes || {};\n    var test_api = kb._test.loadApisFromJson(json);\n    //if (kb_schemes) {\n    //  if (kb_schemes.globals) {\n    //    $.each(kb_schemes.globals, function (parent, rules) {\n    //      test_api.addGlobalAutocompleteRules(parent, rules);\n    //    });\n    //  }\n    //  if (kb_schemes.endpoints) {\n    //    $.each(kb_schemes.endpoints, function (endpoint, scheme) {\n    //      _.defaults(scheme, {methods: null}); // disable method testing unless specified in test\n    //      test_api.addEndpointDescription(endpoint, scheme);\n    //    });\n    //  }\n    //}\n    kb.setActiveApi(test_api);\n\n    input.update(editorValue, function () {\n      input.moveCursorTo(test.cursor.row, test.cursor.column);\n\n      // allow ace rendering to move cursor so it will be seen during test - handy for debugging.\n      setTimeout(function () {\n        input.completer = {\n          base: {},\n          changeListener: function changeListener() {}\n        }; // mimic auto complete\n\n        input.autocomplete._test.getCompletions(input, input.getSession(), test.cursor, \"\", function (err, terms) {\n\n          if (test.assertThrows) {\n            ok(test.assertThrows.test(\"\" + err), \"failed to throw expected exception\");\n            start();\n            return;\n          }\n\n          if (err) {\n            throw err;\n          }\n\n          if (test.no_context) {\n            ok(!terms || terms.length === 0, \"Expected no context bug got terms.\");\n          } else {\n            ok(terms && terms.length > 0, \"failed to extract terms ...\");\n          }\n\n          if (!terms || terms.length === 0) {\n            start();\n            return;\n          }\n\n          if (test[\"autoCompleteSet\"]) {\n            var expected_terms = _lodash2.default.map(test[\"autoCompleteSet\"], function (t) {\n              if ((typeof t === 'undefined' ? 'undefined' : _typeof(t)) !== \"object\") {\n                t = { \"name\": t };\n              }\n              return t;\n            });\n            if (terms.length != expected_terms.length) {\n              equal(_lodash2.default.pluck(terms, 'name'), _lodash2.default.pluck(expected_terms, 'name'), \"list of completion terms is not of equal size\");\n            } else {\n              var filtered_actual_terms = _lodash2.default.map(terms, function (actual_term, i) {\n                var expected_term = expected_terms[i];\n                var filtered_term = {};\n                _lodash2.default.each(expected_term, function (v, p) {\n                  filtered_term[p] = actual_term[p];\n                });\n                return filtered_term;\n              });\n              deepEqual(filtered_actual_terms, expected_terms);\n            }\n          }\n\n          var context = terms[0].context;\n          input.autocomplete._test.addReplacementInfoToContext(context, test.cursor, terms[0].value);\n\n          function ac(prop, prop_test) {\n            if (typeof test[prop] != \"undefined\") {\n              if (prop_test) {\n                prop_test(context[prop], test[prop], prop);\n              } else {\n                deepEqual(context[prop], test[prop], 'context.' + prop + ' should equal ' + JSON.stringify(test[prop]));\n              }\n            }\n          }\n\n          function pos_compare(actual, expected, name) {\n            equal(actual.row, expected.row + rowOffset, \"row of \" + name + \" position is not as expected\");\n            equal(actual.column, expected.column, \"column of \" + name + \" position is not as expected\");\n          }\n\n          function range_compare(actual, expected, name) {\n            pos_compare(actual.start, expected.start, name + \".start\");\n            pos_compare(actual.end, expected.end, name + \".end\");\n          }\n\n          ac(\"prefixToAdd\");\n          ac(\"suffixToAdd\");\n          ac(\"addTemplate\");\n          ac(\"textBoxPosition\", pos_compare);\n          ac(\"rangeToReplace\", range_compare);\n\n          start();\n        });\n      });\n    });\n  });\n}\n\nfunction context_tests(data, mapping, kb_schemes, request_line, tests) {\n  if (data != null && typeof data != \"string\") {\n    data = JSON.stringify(data, null, 3);\n  }\n  for (var t = 0; t < tests.length; t++) {\n    process_context_test(data, mapping, kb_schemes, request_line, tests[t]);\n  }\n}\n\nvar SEARCH_KB = {\n  endpoints: {\n    _search: {\n      methods: [\"GET\", \"POST\"],\n      patterns: [\"{indices}/{types}/_search\", \"{indices}/_search\", \"_search\"],\n      data_autocomplete_rules: {\n        query: { match_all: {}, term: { \"{field}\": { __template: { \"f\": 1 } } } },\n        size: {},\n        facets: {\n          __template: {\n            \"FIELD\": {}\n          },\n          \"*\": { terms: { field: \"{field}\" } }\n        }\n      }\n    }\n  }\n};\n\nvar MAPPING = {\n  \"index1\": {\n    \"type1.1\": {\n      \"properties\": {\n        \"field1.1.1\": { \"type\": \"string\" },\n        \"field1.1.2\": { \"type\": \"string\" }\n      }\n    }\n  },\n  \"index2\": {\n    \"type2.1\": {\n      \"properties\": {\n        \"field2.1.1\": { \"type\": \"string\" },\n        \"field2.1.2\": { \"type\": \"string\" }\n      }\n    }\n  }\n};\n\ncontext_tests({}, MAPPING, SEARCH_KB, \"POST _search\", [{\n  name: \"Empty doc\",\n  cursor: { row: 0, column: 1 },\n  initialValue: \"\",\n  addTemplate: true,\n  prefixToAdd: \"\",\n  suffixToAdd: \"\",\n  rangeToReplace: { start: { row: 0, column: 1 }, end: { row: 0, column: 1 } },\n  autoCompleteSet: [\"facets\", \"query\", \"size\"]\n}]);\n\ncontext_tests({}, MAPPING, SEARCH_KB, \"POST _no_context\", [{\n  name: \"Missing KB\",\n  cursor: { row: 0, column: 1 },\n  no_context: true\n}]);\n\ncontext_tests({\n  \"query\": {\n    \"f\": 1\n  }\n}, MAPPING, {\n  globals: {\n    query: {\n      t1: 2\n    }\n  },\n  endpoints: {}\n}, \"POST _no_context\", [{\n  name: \"Missing KB - global auto complete\",\n  cursor: { row: 2, column: 5 },\n  autoCompleteSet: [\"t1\"]\n}]);\n\ncontext_tests({\n  \"query\": {\n    \"field\": \"something\"\n  },\n  \"facets\": {},\n  \"size\": 20\n}, MAPPING, SEARCH_KB, \"POST _search\", [{\n  name: \"existing dictionary key, no template\",\n  cursor: { row: 1, column: 6 },\n  initialValue: \"query\",\n  addTemplate: false,\n  prefixToAdd: \"\",\n  suffixToAdd: \"\",\n  rangeToReplace: { start: { row: 1, column: 3 }, end: { row: 1, column: 10 } },\n  autoCompleteSet: [\"facets\", \"query\", \"size\"]\n}, {\n  name: \"existing inner dictionary key\",\n  cursor: { row: 2, column: 7 },\n  initialValue: \"field\",\n  addTemplate: false,\n  prefixToAdd: \"\",\n  suffixToAdd: \"\",\n  rangeToReplace: { start: { row: 2, column: 6 }, end: { row: 2, column: 13 } },\n  autoCompleteSet: [\"match_all\", \"term\"]\n}, {\n  name: \"existing dictionary key, yes template\",\n  cursor: { row: 4, column: 7 },\n  initialValue: \"facets\",\n  addTemplate: true,\n  prefixToAdd: \"\",\n  suffixToAdd: \"\",\n  rangeToReplace: { start: { row: 4, column: 3 }, end: { row: 4, column: 15 } },\n  autoCompleteSet: [\"facets\", \"query\", \"size\"]\n}, {\n  name: \"ignoring meta keys\",\n  cursor: { row: 4, column: 14 },\n  no_context: true\n}]);\n\ncontext_tests('{\\n' + '   \"query\": {\\n' + '    \"field\": \"something\"\\n' + '   },\\n' + '   \"facets\": {},\\n' + '   \"size\": 20 \\n' + '}', MAPPING, SEARCH_KB, \"POST _search\", [{\n  name: \"trailing comma, end of line\",\n  cursor: { row: 4, column: 16 },\n  initialValue: \"\",\n  addTemplate: true,\n  prefixToAdd: \"\",\n  suffixToAdd: \", \",\n  rangeToReplace: { start: { row: 4, column: 16 }, end: { row: 4, column: 16 } },\n  autoCompleteSet: [\"facets\", \"query\", \"size\"]\n}, {\n  name: \"trailing comma, beginning of line\",\n  cursor: { row: 5, column: 1 },\n  initialValue: \"\",\n  addTemplate: true,\n  prefixToAdd: \"\",\n  suffixToAdd: \", \",\n  rangeToReplace: { start: { row: 5, column: 1 }, end: { row: 5, column: 1 } },\n  autoCompleteSet: [\"facets\", \"query\", \"size\"]\n}, {\n  name: \"prefix comma, beginning of line\",\n  cursor: { row: 6, column: 0 },\n  initialValue: \"\",\n  addTemplate: true,\n  prefixToAdd: \", \",\n  suffixToAdd: \"\",\n  rangeToReplace: { start: { row: 6, column: 0 }, end: { row: 6, column: 0 } },\n  autoCompleteSet: [\"facets\", \"query\", \"size\"]\n}, {\n  name: \"prefix comma, end of line\",\n  cursor: { row: 5, column: 14 },\n  initialValue: \"\",\n  addTemplate: true,\n  prefixToAdd: \", \",\n  suffixToAdd: \"\",\n  rangeToReplace: { start: { row: 5, column: 14 }, end: { row: 5, column: 14 } },\n  autoCompleteSet: [\"facets\", \"query\", \"size\"]\n}]);\n\ncontext_tests({\n  \"object\": 1,\n  \"array\": 1,\n  \"value_one_of\": 1,\n  \"value\": 2,\n  \"something_else\": 5\n}, MAPPING, {\n  endpoints: {\n    _test: {\n      patterns: [\"_test\"],\n      data_autocomplete_rules: {\n        object: { bla: 1 },\n        array: [1],\n        value_one_of: { __one_of: [1, 2] },\n        value: 3,\n        \"*\": { __one_of: [4, 5] }\n      }\n    }\n  }\n}, \"GET _test\", [{\n  name: \"not matching object when { is not opened\",\n  cursor: { row: 1, column: 12 },\n  initialValue: \"\",\n  autoCompleteSet: [\"{\"]\n}, {\n  name: \"not matching array when [ is not opened\",\n  cursor: { row: 2, column: 12 },\n  initialValue: \"\",\n  autoCompleteSet: [\"[\"]\n}, {\n  name: \"matching value with one_of\",\n  cursor: { row: 3, column: 19 },\n  initialValue: \"\",\n  autoCompleteSet: [1, 2]\n}, {\n  name: \"matching value\",\n  cursor: { row: 4, column: 12 },\n  initialValue: \"\",\n  autoCompleteSet: [3]\n}, {\n  name: \"matching any value with one_of\",\n  cursor: { row: 5, column: 21 },\n  initialValue: \"\",\n  autoCompleteSet: [4, 5]\n}]);\n\ncontext_tests({\n  \"query\": {\n    \"field\": \"something\"\n  },\n  \"facets\": {\n    \"name\": {}\n  },\n  \"size\": 20\n}, MAPPING, SEARCH_KB, \"GET _search\", [{\n  name: \"* matching everything\",\n  cursor: { row: 5, column: 15 },\n  initialValue: \"\",\n  addTemplate: true,\n  prefixToAdd: \"\",\n  suffixToAdd: \"\",\n  rangeToReplace: { start: { row: 5, column: 15 }, end: { row: 5, column: 15 } },\n  autoCompleteSet: [{ name: \"terms\", meta: \"API\" }]\n}]);\n\ncontext_tests({\n  \"index\": \"123\"\n}, MAPPING, {\n  endpoints: {\n    _test: {\n      patterns: [\"_test\"],\n      data_autocomplete_rules: {\n        index: \"{index}\"\n      }\n    }\n  }\n}, \"GET _test\", [{\n  name: \"{index} matching\",\n  cursor: { row: 1, column: 15 },\n  autoCompleteSet: [{ name: \"index1\", meta: \"index\" }, { name: \"index2\", meta: \"index\" }]\n}]);\n\nfunction tt(term, template, meta) {\n  term = { name: term, template: template };\n  if (meta) {\n    term.meta = meta;\n  }\n  return term;\n}\n\ncontext_tests({\n  \"array\": [\"a\"],\n  \"oneof\": \"1\"\n}, MAPPING, {\n  endpoints: {\n    _endpoint: {\n      patterns: [\"_endpoint\"],\n      data_autocomplete_rules: {\n        array: [\"a\", \"b\"],\n        number: 1,\n        object: {},\n        fixed: { __template: { \"a\": 1 } },\n        oneof: { __one_of: [\"o1\", \"o2\"] }\n      }\n    }\n  }\n}, \"GET _endpoint\", [{\n  name: \"Templates 1\",\n  cursor: { row: 1, column: 0 },\n  autoCompleteSet: [tt(\"array\", []), tt(\"fixed\", { a: 1 }), tt(\"number\", 1), tt(\"object\", {}), tt(\"oneof\", \"o1\")]\n}, {\n  name: \"Templates - one off\",\n  cursor: { row: 4, column: 12 },\n  autoCompleteSet: [tt(\"o1\"), tt(\"o2\")]\n}]);\n\ncontext_tests({\n  \"string\": \"value\",\n  \"context\": {}\n}, MAPPING, {\n  endpoints: {\n    _endpoint: {\n      patterns: [\"_endpoint\"],\n      data_autocomplete_rules: {\n        context: {\n          __one_of: [{\n            __condition: {\n              lines_regex: \"value\"\n            },\n            \"match\": {}\n          }, {\n            __condition: {\n              lines_regex: \"other\"\n            },\n            \"no_match\": {}\n          }, { \"always\": {} }]\n        }\n      }\n    }\n  }\n}, \"GET _endpoint\", [{\n  name: \"Conditionals\",\n  cursor: { row: 2, column: 15 },\n  autoCompleteSet: [tt(\"always\", {}), tt(\"match\", {})]\n}]);\n\ncontext_tests({\n  \"any_of_numbers\": [1],\n  \"any_of_obj\": [{\n    \"a\": 1\n  }],\n  \"any_of_mixed\": [{\n    \"a\": 1\n  }, 2]\n}, MAPPING, {\n  endpoints: {\n    _endpoint: {\n      patterns: [\"_endpoint\"],\n      data_autocomplete_rules: {\n        any_of_numbers: { __template: [1, 2], __any_of: [1, 2, 3] },\n        any_of_obj: {\n          __template: [{ c: 1 }], __any_of: [{ a: 1, b: 2 }, { c: 1 }]\n        },\n        any_of_mixed: {\n          __any_of: [{ a: 1 }, 3]\n        }\n      }\n    }\n  }\n}, \"GET _endpoint\", [{\n  name: \"Any of - templates\",\n  cursor: { row: 1, column: 0 },\n  autoCompleteSet: [tt(\"any_of_mixed\", []), tt(\"any_of_numbers\", [1, 2]), tt(\"any_of_obj\", [{ c: 1 }])]\n}, {\n  name: \"Any of - numbers\",\n  cursor: { row: 2, column: 2 },\n  autoCompleteSet: [1, 2, 3]\n}, {\n  name: \"Any of - object\",\n  cursor: { row: 6, column: 2 },\n  autoCompleteSet: [tt(\"a\", 1), tt(\"b\", 2), tt(\"c\", 1)]\n}, {\n  name: \"Any of - mixed - obj\",\n  cursor: { row: 11, column: 2 },\n  autoCompleteSet: [tt(\"a\", 1)]\n}, {\n  name: \"Any of - mixed - both\",\n  cursor: { row: 13, column: 2 },\n  autoCompleteSet: [tt(\"{\"), tt(3)]\n}]);\n\ncontext_tests({}, MAPPING, {\n  endpoints: {\n    _endpoint: {\n      patterns: [\"_endpoint\"],\n      data_autocomplete_rules: {\n        \"query\": \"\"\n      }\n    }\n  }\n}, \"GET _endpoint\", [{\n  name: \"Empty string as default\",\n  cursor: { row: 0, column: 1 },\n  autoCompleteSet: [tt(\"query\", \"\")]\n}]);\n\ncontext_tests({\n  \"a\": {\n    \"b\": {},\n    \"c\": {},\n    \"d\": {\n      t1a: {}\n    },\n    \"e\": {},\n    \"f\": [{}],\n    \"g\": {},\n    \"h\": {}\n  }\n}, MAPPING, {\n  globals: {\n    gtarget: {\n      t1: 2,\n      t1a: {\n        __scope_link: \".\"\n      }\n    }\n  },\n  endpoints: {\n    _current: {\n      patterns: [\"_current\"],\n      data_autocomplete_rules: {\n        \"a\": {\n          \"b\": {\n            __scope_link: \".a\"\n          },\n          \"c\": {\n            __scope_link: \"ext.target\"\n          },\n          \"d\": {\n            __scope_link: \"GLOBAL.gtarget\"\n          },\n          \"e\": {\n            __scope_link: \"ext\"\n          },\n          \"f\": [{\n            __scope_link: \"ext.target\"\n          }],\n          \"g\": {\n            __scope_link: function __scope_link() {\n              return {\n                \"a\": 1,\n                \"b\": 2\n              };\n            }\n          },\n          \"h\": {\n            __scope_link: \"GLOBAL.broken\"\n          }\n        }\n      }\n    },\n    ext: {\n      patterns: [\"ext\"],\n      data_autocomplete_rules: {\n        target: {\n          t2: 1\n        }\n      }\n    }\n  }\n}, \"GET _current\", [{\n  name: \"Relative scope link test\",\n  cursor: { row: 2, column: 12 },\n  autoCompleteSet: [tt(\"b\", {}), tt(\"c\", {}), tt(\"d\", {}), tt(\"e\", {}), tt(\"f\", [{}]), tt(\"g\", {}), tt(\"h\", {})]\n}, {\n  name: \"External scope link test\",\n  cursor: { row: 3, column: 12 },\n  autoCompleteSet: [tt(\"t2\", 1)]\n}, {\n  name: \"Global scope link test\",\n  cursor: { row: 4, column: 12 },\n  autoCompleteSet: [tt(\"t1\", 2), tt(\"t1a\", {})]\n}, {\n  name: \"Global scope link with an internal scope link\",\n  cursor: { row: 5, column: 17 },\n  autoCompleteSet: [tt(\"t1\", 2), tt(\"t1a\", {})]\n}, {\n  name: \"Entire endpoint scope link test\",\n  cursor: { row: 7, column: 12 },\n  autoCompleteSet: [tt(\"target\", {})]\n}, {\n  name: \"A scope link within an array\",\n  cursor: { row: 9, column: 10 },\n  autoCompleteSet: [tt(\"t2\", 1)]\n}, {\n  name: \"A function based scope link\",\n  cursor: { row: 11, column: 12 },\n  autoCompleteSet: [tt(\"a\", 1), tt(\"b\", 2)]\n}, {\n  name: \"A global scope link with wrong link\",\n  cursor: { row: 12, column: 12 },\n  assertThrows: /broken/\n\n}]);\n\ncontext_tests({}, MAPPING, {\n  globals: {\n    gtarget: {\n      t1: 2\n    }\n  },\n  endpoints: {\n    _current: {\n      patterns: [\"_current\"],\n      id: \"GET _current\",\n      data_autocomplete_rules: {\n        __scope_link: \"GLOBAL.gtarget\"\n      }\n    }\n  }\n}, \"GET _current\", [{\n  name: \"Top level scope link\",\n  cursor: { row: 0, column: 1 },\n  autoCompleteSet: [tt(\"t1\", 2)]\n}]);\n\ncontext_tests({\n  \"a\": {}\n}, MAPPING, {\n  endpoints: {\n    _endpoint: {\n      patterns: [\"_endpoint\"],\n      data_autocomplete_rules: {\n        \"a\": {},\n        \"b\": {}\n      }\n    }\n  }\n}, \"GET _endpoint\", [{\n  name: \"Path after empty object\",\n  cursor: { row: 1, column: 10 },\n  autoCompleteSet: [\"a\", \"b\"]\n}]);\n\ncontext_tests({\n  \"\": {}\n}, MAPPING, SEARCH_KB, \"POST _search\", [{\n  name: \"Replace an empty string\",\n  cursor: { row: 1, column: 4 },\n  rangeToReplace: { start: { row: 1, column: 3 }, end: { row: 1, column: 9 } }\n}]);\n\ncontext_tests({\n  \"a\": [{\n    \"c\": {}\n  }]\n}, MAPPING, {\n  endpoints: {\n    _endpoint: {\n      patterns: [\"_endpoint\"],\n      data_autocomplete_rules: {\n        \"a\": [{ b: 1 }]\n      }\n    }\n  }\n}, \"GET _endpoint\", [{\n  name: \"List of objects - internal autocomplete\",\n  cursor: { row: 3, column: 10 },\n  autoCompleteSet: [\"b\"]\n}, {\n  name: \"List of objects - external template\",\n  cursor: { row: 0, column: 1 },\n  autoCompleteSet: [tt(\"a\", [{}])]\n}]);\n\ncontext_tests({\n  \"query\": {\n    \"term\": {\n      \"field\": \"something\"\n    }\n  },\n  \"facets\": {\n    \"test\": {\n      \"terms\": {\n        \"field\": \"test\"\n      }\n    }\n  },\n  \"size\": 20\n}, MAPPING, SEARCH_KB, \"POST index1/_search\", [{\n  name: \"Field completion as scope\",\n  cursor: { row: 3, column: 10 },\n  autoCompleteSet: [tt(\"field1.1.1\", { \"f\": 1 }, \"string\"), tt(\"field1.1.2\", { \"f\": 1 }, \"string\")]\n}, {\n  name: \"Field completion as value\",\n  cursor: { row: 9, column: 23 },\n  autoCompleteSet: [{ name: \"field1.1.1\", meta: \"string\" }, { name: \"field1.1.2\", meta: \"string\" }]\n}]);\n\ncontext_tests(\"POST _search\", MAPPING, SEARCH_KB, null, [{\n  name: \"initial doc start\",\n  cursor: { row: 1, column: 0 },\n  autoCompleteSet: [\"{\"],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\"\n}]);\n\ncontext_tests('{\\n' + '   \"query\": {} \\n' + '}\\n' + '\\n' + '\\n', MAPPING, SEARCH_KB, \"POST _search\", [{\n  name: \"Cursor rows after request end\",\n  cursor: { row: 4, column: 0 },\n  autoCompleteSet: [\"GET\", \"PUT\", \"POST\", \"DELETE\", \"HEAD\"],\n  prefixToAdd: \"\",\n  suffixToAdd: \" \"\n}, {\n  name: \"Cursor just after request end\",\n  cursor: { row: 2, column: 1 },\n  no_context: true\n}]);\n\nvar CLUSTER_KB = {\n  endpoints: {\n    \"_search\": {\n      patterns: [\"_search\", \"{indices}/{types}/_search\", \"{indices}/_search\"],\n      url_params: {\n        \"search_type\": [\"count\", \"query_then_fetch\"],\n        \"scroll\": \"10m\"\n      },\n      data_autocomplete_rules: {}\n    },\n    \"_cluster/stats\": {\n      patterns: [\"_cluster/stats\"],\n      indices_mode: \"none\",\n      data_autocomplete_rules: {}\n    },\n    \"_cluster/nodes/stats\": {\n      patterns: [\"_cluster/nodes/stats\"],\n      data_autocomplete_rules: {}\n    }\n  }\n};\n\ncontext_tests(null, MAPPING, CLUSTER_KB, \"GET _cluster\", [{\n  name: \"Endpoints with slashes - no slash\",\n  cursor: { row: 0, column: 8 },\n  autoCompleteSet: [\"_cluster/nodes/stats\", \"_cluster/stats\", \"_search\", \"index1\", \"index2\"],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\"\n}]);\n\ncontext_tests(null, MAPPING, CLUSTER_KB, \"GET _cluster/\", [{\n  name: \"Endpoints with slashes - before slash\",\n  cursor: { row: 0, column: 7 },\n  autoCompleteSet: [\"_cluster/nodes/stats\", \"_cluster/stats\", \"_search\", \"index1\", \"index2\"],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\"\n}, {\n  name: \"Endpoints with slashes - on slash\",\n  cursor: { row: 0, column: 12 },\n  autoCompleteSet: [\"_cluster/nodes/stats\", \"_cluster/stats\", \"_search\", \"index1\", \"index2\"],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\"\n}, {\n  name: \"Endpoints with slashes - after slash\",\n  cursor: { row: 0, column: 13 },\n  autoCompleteSet: [\"nodes/stats\", \"stats\"],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\"\n}]);\n\ncontext_tests(null, MAPPING, CLUSTER_KB, \"GET _cluster/no\", [{\n  name: \"Endpoints with slashes - after slash\",\n  cursor: { row: 0, column: 14 },\n  autoCompleteSet: [{ name: \"nodes/stats\", meta: \"endpoint\" }, { name: \"stats\", meta: \"endpoint\" }],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\",\n  initialValue: \"no\"\n}]);\n\ncontext_tests(null, MAPPING, CLUSTER_KB, \"GET _cluster/nodes/st\", [{\n  name: \"Endpoints with two slashes\",\n  cursor: { row: 0, column: 20 },\n  autoCompleteSet: [\"stats\"],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\",\n  initialValue: \"st\"\n}]);\n\ncontext_tests(null, MAPPING, CLUSTER_KB, \"GET \", [{\n  name: \"Immediately after space + method\",\n  cursor: { row: 0, column: 4 },\n  autoCompleteSet: [{ name: \"_cluster/nodes/stats\", meta: \"endpoint\" }, { name: \"_cluster/stats\", meta: \"endpoint\" }, { name: \"_search\", meta: \"endpoint\" }, { name: \"index1\", meta: \"index\" }, { name: \"index2\", meta: \"index\" }],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\",\n  initialValue: \"\"\n}]);\n\ncontext_tests(null, MAPPING, CLUSTER_KB, \"GET cl\", [{\n  name: \"Endpoints by subpart\",\n  cursor: { row: 0, column: 6 },\n  autoCompleteSet: [{ name: \"_cluster/nodes/stats\", meta: \"endpoint\" }, { name: \"_cluster/stats\", meta: \"endpoint\" }, { name: \"_search\", meta: \"endpoint\" }, { name: \"index1\", meta: \"index\" }, { name: \"index2\", meta: \"index\" }],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\",\n  initialValue: \"cl\"\n}]);\n\ncontext_tests(null, MAPPING, CLUSTER_KB, \"POST cl\", [{\n  name: \"Endpoints by subpart\",\n  cursor: { row: 0, column: 7 },\n  autoCompleteSet: [{ name: \"_cluster/nodes/stats\", meta: \"endpoint\" }, { name: \"_cluster/stats\", meta: \"endpoint\" }, { name: \"_search\", meta: \"endpoint\" }, { name: \"index1\", meta: \"index\" }, { name: \"index2\", meta: \"index\" }],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\",\n  initialValue: \"cl\"\n}]);\n\ncontext_tests(null, MAPPING, CLUSTER_KB, \"GET _search?\", [{\n  name: \"Params just after ?\",\n  cursor: { row: 0, column: 12 },\n  autoCompleteSet: [{ name: \"filter_path\", meta: \"param\", \"insert_value\": \"filter_path=\" }, { name: \"format\", meta: \"param\", \"insert_value\": \"format=\" }, { name: \"pretty\", meta: \"flag\" }, { name: \"scroll\", meta: \"param\", \"insert_value\": \"scroll=\" }, { name: \"search_type\", meta: \"param\", \"insert_value\": \"search_type=\" }],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\"\n}]);\n\ncontext_tests(null, MAPPING, CLUSTER_KB, \"GET _search?format=\", [{\n  name: \"Params values\",\n  cursor: { row: 0, column: 19 },\n  autoCompleteSet: [{ name: \"json\", meta: \"format\" }, { name: \"yaml\", meta: \"format\" }],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\"\n}]);\n\ncontext_tests(null, MAPPING, CLUSTER_KB, \"GET _search?format=yaml&\", [{\n  name: \"Params after amp\",\n  cursor: { row: 0, column: 24 },\n  autoCompleteSet: [{ name: \"filter_path\", meta: \"param\", \"insert_value\": \"filter_path=\" }, { name: \"format\", meta: \"param\", \"insert_value\": \"format=\" }, { name: \"pretty\", meta: \"flag\" }, { name: \"scroll\", meta: \"param\", \"insert_value\": \"scroll=\" }, { name: \"search_type\", meta: \"param\", \"insert_value\": \"search_type=\" }],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\"\n}]);\n\ncontext_tests(null, MAPPING, CLUSTER_KB, \"GET _search?format=yaml&search\", [{\n  name: \"Params on existing param\",\n  cursor: { row: 0, column: 26 },\n  rangeToReplace: {\n    start: { row: 0, column: 24 },\n    end: { row: 0, column: 30 }\n  },\n  autoCompleteSet: [{ name: \"filter_path\", meta: \"param\", \"insert_value\": \"filter_path=\" }, { name: \"format\", meta: \"param\", \"insert_value\": \"format=\" }, { name: \"pretty\", meta: \"flag\" }, { name: \"scroll\", meta: \"param\", \"insert_value\": \"scroll=\" }, { name: \"search_type\", meta: \"param\", \"insert_value\": \"search_type=\" }],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\"\n}]);\n\ncontext_tests(null, MAPPING, CLUSTER_KB, \"GET _search?format=yaml&search_type=cou\", [{\n  name: \"Params on existing value\",\n  cursor: { row: 0, column: 37 },\n  rangeToReplace: {\n    start: { row: 0, column: 36 },\n    end: { row: 0, column: 39 }\n  },\n  autoCompleteSet: [{ name: \"count\", meta: \"search_type\" }, { name: \"query_then_fetch\", meta: \"search_type\" }],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\"\n}]);\ncontext_tests(null, MAPPING, CLUSTER_KB, \"GET _search?format=yaml&search_type=cou\", [{\n  name: \"Params on just after = with existing value\",\n  cursor: { row: 0, column: 36 },\n  rangeToReplace: {\n    start: { row: 0, column: 36 },\n    end: { row: 0, column: 36 }\n  },\n  autoCompleteSet: [{ name: \"count\", meta: \"search_type\" }, { name: \"query_then_fetch\", meta: \"search_type\" }],\n  prefixToAdd: \"\",\n  suffixToAdd: \"\"\n}]);\n\ncontext_tests({\n  \"query\": {\n    \"field\": \"something\"\n  },\n  \"facets\": {},\n  \"size\": 20\n}, MAPPING, SEARCH_KB, \"POST http://somehost/_search\", [{\n  name: \"fullurl - existing dictionary key, no template\",\n  cursor: { row: 1, column: 6 },\n  initialValue: \"query\",\n  addTemplate: false,\n  prefixToAdd: \"\",\n  suffixToAdd: \"\",\n  rangeToReplace: { start: { row: 1, column: 3 }, end: { row: 1, column: 10 } },\n  autoCompleteSet: [\"facets\", \"query\", \"size\"]\n}, {\n  name: \"fullurl - existing inner dictionary key\",\n  cursor: { row: 2, column: 7 },\n  initialValue: \"field\",\n  addTemplate: false,\n  prefixToAdd: \"\",\n  suffixToAdd: \"\",\n  rangeToReplace: { start: { row: 2, column: 6 }, end: { row: 2, column: 13 } },\n  autoCompleteSet: [\"match_all\", \"term\"]\n}, {\n  name: \"fullurl - existing dictionary key, yes template\",\n  cursor: { row: 4, column: 7 },\n  initialValue: \"facets\",\n  addTemplate: true,\n  prefixToAdd: \"\",\n  suffixToAdd: \"\",\n  rangeToReplace: { start: { row: 4, column: 3 }, end: { row: 4, column: 15 } },\n  autoCompleteSet: [\"facets\", \"query\", \"size\"]\n}]);",null]}