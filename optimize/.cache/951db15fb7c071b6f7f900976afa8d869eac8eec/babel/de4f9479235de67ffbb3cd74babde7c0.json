{"remainingRequest":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\babel-loader\\lib\\index.js??ref--6-1!C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\src\\ui\\public\\agg_types\\buckets\\_terms_other_bucket_helper.js","dependencies":[{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\src\\ui\\public\\agg_types\\buckets\\_terms_other_bucket_helper.js","mtime":1525446317784},{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1493198456000},{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\babel-loader\\lib\\index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OtherBucketHelperProvider = undefined;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _agg_config = require('ui/vis/agg_config');\n\nvar _phrases = require('ui/filter_manager/lib/phrases');\n\nvar _exists = require('ui/filter_manager/lib/exists');\n\nvar _from_filters = require('ui/courier/data_source/build_query/from_filters');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * walks the aggregation DSL and returns DSL starting at aggregation with id of startFromAggId\n * @param aggNestedDsl: aggregation config DSL (top level)\n * @param startFromId: id of an aggregation from where we want to get the nested DSL\n */\nvar getNestedAggDSL = function getNestedAggDSL(aggNestedDsl, startFromAggId) {\n  if (aggNestedDsl[startFromAggId]) return aggNestedDsl[startFromAggId];\n  return getNestedAggDSL(_lodash2.default.values(aggNestedDsl)[0].aggs, startFromAggId);\n};\n\n/**\n * returns buckets from response for a specific other bucket\n * @param aggConfigs: configuration for the aggregations\n * @param response: response from elasticsearch\n * @param aggWithOtherBucket: AggConfig of the aggregation with other bucket enabled\n * @param key: key from the other bucket request for a specific other bucket\n */\nvar getAggResultBuckets = function getAggResultBuckets(aggConfigs, response, aggWithOtherBucket, key) {\n  var keyParts = key.split('-');\n  var responseAgg = response;\n\n  var _loop = function _loop(i) {\n    if (keyParts[i]) {\n      var agg = _lodash2.default.values(responseAgg)[0];\n      var aggKey = _lodash2.default.keys(responseAgg)[0];\n      var aggConfig = _lodash2.default.find(aggConfigs, function (agg) {\n        return agg.id === aggKey;\n      });\n      var bucket = _lodash2.default.find(agg.buckets, function (bucket, bucketObjKey) {\n        var bucketKey = aggConfig.getKey(bucket, Number.isInteger(bucketObjKey) ? null : bucketObjKey).toString();\n        return bucketKey === keyParts[i];\n      });\n      if (bucket) {\n        responseAgg = bucket;\n      }\n    }\n  };\n\n  for (var i in keyParts) {\n    _loop(i);\n  }\n  if (responseAgg[aggWithOtherBucket.id]) return responseAgg[aggWithOtherBucket.id].buckets;\n  return [];\n};\n\n/**\n * gets all the missing buckets in our response for a specific aggregation id\n * @param responseAggs: array of aggregations from response\n * @param aggId: id of the aggregation with missing bucket\n */\nvar getAggConfigResultMissingBuckets = function getAggConfigResultMissingBuckets(responseAggs, aggId) {\n  var missingKey = '__missing__';\n  var resultBuckets = [];\n  if (responseAggs[aggId]) {\n    var matchingBucket = responseAggs[aggId].buckets.find(function (bucket) {\n      return bucket.key === missingKey;\n    });\n    if (matchingBucket) resultBuckets.push(matchingBucket);\n    return resultBuckets;\n  }\n  _lodash2.default.each(responseAggs, function (agg) {\n    if (agg.buckets) {\n      _lodash2.default.each(agg.buckets, function (bucket) {\n        resultBuckets = [].concat(_toConsumableArray(resultBuckets), _toConsumableArray(getAggConfigResultMissingBuckets(bucket, aggId, missingKey)));\n      });\n    }\n  });\n\n  return resultBuckets;\n};\n\n/**\n * gets all the terms that are NOT in the other bucket\n * @param requestAgg: an aggregation we are looking at\n * @param key: the key for this specific other bucket\n * @param otherAgg: AggConfig of the aggregation with other bucket\n */\nvar getOtherAggTerms = function getOtherAggTerms(requestAgg, key, otherAgg) {\n  return requestAgg['other-filter'].filters.filters[key].bool.must_not.filter(function (filter) {\n    return filter.match_phrase && filter.match_phrase[otherAgg.params.field.name];\n  }).map(function (filter) {\n    return filter.match_phrase[otherAgg.params.field.name].query;\n  });\n};\n\nvar OtherBucketHelperProvider = exports.OtherBucketHelperProvider = function OtherBucketHelperProvider(Private) {\n  var AggConfig = Private(_agg_config.VisAggConfigProvider);\n\n  var buildOtherBucketAgg = function buildOtherBucketAgg(aggConfigs, aggWithOtherBucket, response) {\n    var bucketAggs = aggConfigs.filter(function (agg) {\n      return agg.type.type === 'buckets';\n    });\n    var index = bucketAggs.findIndex(function (agg) {\n      return agg.id === aggWithOtherBucket.id;\n    });\n    var aggs = aggConfigs.toDsl();\n    var indexPattern = aggWithOtherBucket.params.field.indexPattern;\n\n    // create filters aggregation\n    var filterAgg = new AggConfig(aggConfigs[index].vis, {\n      type: 'filters',\n      id: 'other',\n      schema: {\n        group: 'buckets'\n      }\n    });\n\n    // nest all the child aggregations of aggWithOtherBucket\n    var resultAgg = {\n      aggs: getNestedAggDSL(aggs, aggWithOtherBucket.id).aggs,\n      filters: filterAgg.toDsl()\n    };\n\n    // create filters for all parent aggregation buckets\n    var walkBucketTree = function walkBucketTree(aggIndex, aggs, aggId, filters, key) {\n      var agg = aggs[aggId];\n      var newAggIndex = aggIndex + 1;\n      var newAgg = bucketAggs[newAggIndex];\n      var currentAgg = bucketAggs[aggIndex];\n      if (aggIndex < index) {\n        _lodash2.default.each(agg.buckets, function (bucket, bucketObjKey) {\n          var bucketKey = currentAgg.getKey(bucket, Number.isInteger(bucketObjKey) ? null : bucketObjKey);\n          var filter = _lodash2.default.cloneDeep(bucket.filter) || currentAgg.createFilter(bucketKey);\n          var newFilters = [].concat(_toConsumableArray(filters), [filter]);\n          walkBucketTree(newAggIndex, bucket, newAgg.id, newFilters, key + '-' + bucketKey.toString());\n        });\n        return;\n      }\n\n      if (!aggWithOtherBucket.params.missingBucket || agg.buckets.some(function (bucket) {\n        return bucket.key === '__missing__';\n      })) {\n        filters.push((0, _exists.buildExistsFilter)(aggWithOtherBucket.params.field, aggWithOtherBucket.params.field.indexPattern));\n      }\n\n      // create not filters for all the buckets\n      _lodash2.default.each(agg.buckets, function (bucket) {\n        if (bucket.key === '__missing__') return;\n        var filter = currentAgg.createFilter(bucket.key);\n        filter.meta.negate = true;\n        filters.push(filter);\n      });\n\n      resultAgg.filters.filters[key] = {\n        bool: (0, _from_filters.buildQueryFromFilters)(filters, _lodash2.default.noop, indexPattern)\n      };\n    };\n    walkBucketTree(0, response.aggregations, bucketAggs[0].id, [], '');\n\n    return function () {\n      return {\n        'other-filter': resultAgg\n      };\n    };\n  };\n\n  var mergeOtherBucketAggResponse = function mergeOtherBucketAggResponse(aggsConfig, response, otherResponse, otherAgg, requestAgg) {\n    var updatedResponse = _lodash2.default.cloneDeep(response);\n    _lodash2.default.each(otherResponse.aggregations['other-filter'].buckets, function (bucket, key) {\n      if (!bucket.doc_count) return;\n      var bucketKey = key.replace(/^-/, '');\n      var aggResultBuckets = getAggResultBuckets(aggsConfig, updatedResponse.aggregations, otherAgg, bucketKey);\n      var requestFilterTerms = getOtherAggTerms(requestAgg, key, otherAgg);\n\n      var phraseFilter = (0, _phrases.buildPhrasesFilter)(otherAgg.params.field, requestFilterTerms, otherAgg.params.field.indexPattern);\n      phraseFilter.meta.negate = true;\n      bucket.filters = [phraseFilter];\n      bucket.key = otherAgg.params.otherBucketLabel;\n\n      if (aggResultBuckets.some(function (bucket) {\n        return bucket.key === '__missing__';\n      })) {\n        bucket.filters.push((0, _exists.buildExistsFilter)(otherAgg.params.field, otherAgg.params.field.indexPattern));\n      }\n\n      aggResultBuckets.push(bucket);\n    });\n    return updatedResponse;\n  };\n\n  var updateMissingBucket = function updateMissingBucket(response, aggConfigs, agg) {\n    var updatedResponse = _lodash2.default.cloneDeep(response);\n    var aggResultBuckets = getAggConfigResultMissingBuckets(updatedResponse.aggregations, agg.id);\n    aggResultBuckets.forEach(function (bucket) {\n      bucket.key = agg.params.missingBucketLabel;\n      var existsFilter = (0, _exists.buildExistsFilter)(agg.params.field, agg.params.field.indexPattern);\n      existsFilter.meta.negate = true;\n      bucket.filters = [existsFilter];\n    });\n    return updatedResponse;\n  };\n\n  return { buildOtherBucketAgg: buildOtherBucketAgg, mergeOtherBucketAggResponse: mergeOtherBucketAggResponse, updateMissingBucket: updateMissingBucket };\n};",null]}