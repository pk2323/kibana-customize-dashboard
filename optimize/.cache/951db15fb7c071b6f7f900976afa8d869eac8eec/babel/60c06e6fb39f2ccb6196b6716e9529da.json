{"remainingRequest":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\babel-loader\\lib\\index.js??ref--6-1!C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\src\\core_plugins\\tile_map\\public\\base_maps_visualization.js","dependencies":[{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\src\\core_plugins\\tile_map\\public\\base_maps_visualization.js","mtime":1525446270373},{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1493198456000},{"path":"C:\\Users\\Prashanth\\Desktop\\ELk\\kibana-6.2.4\\kibana-6.2.4\\node_modules\\babel-loader\\lib\\index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.BaseMapsVisualizationProvider = BaseMapsVisualizationProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _kibana_map = require('./kibana_map');\n\nvar _Rx = require('rxjs/Rx');\n\nrequire('ui/vis/map/service_settings');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MINZOOM = 0;\nvar MAXZOOM = 18;\n\nfunction BaseMapsVisualizationProvider(serviceSettings) {\n\n  /**\n   * Abstract base class for a visualization consisting of a map with a single baselayer.\n   * @class BaseMapsVisualization\n   * @constructor\n   */\n  return function () {\n    function BaseMapsVisualization(element, vis) {\n      _classCallCheck(this, BaseMapsVisualization);\n\n      this.vis = vis;\n      this._container = element;\n      this._kibanaMap = null;\n      this._baseLayerDirty = true;\n      this._mapIsLoaded = this._makeKibanaMap();\n    }\n\n    _createClass(BaseMapsVisualization, [{\n      key: 'destroy',\n      value: function destroy() {\n        if (this._kibanaMap) {\n          this._kibanaMap.destroy();\n          this._kibanaMap = null;\n        }\n      }\n\n      /**\n       * checks whether the data is usable.\n       * @return {boolean}\n       */\n\n    }, {\n      key: 'isDataUsable',\n      value: function isDataUsable() {\n        return true;\n      }\n\n      /**\n       * Implementation of Visualization#render.\n       * Child-classes can extend this method if the render-complete function requires more time until rendering has completed.\n       * @param esResponse\n       * @param status\n       * @return {Promise}\n       */\n\n    }, {\n      key: 'render',\n      value: function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(esResponse, status) {\n          return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (this._kibanaMap) {\n                    _context.next = 2;\n                    break;\n                  }\n\n                  return _context.abrupt('return');\n\n                case 2:\n                  _context.next = 4;\n                  return this._mapIsLoaded;\n\n                case 4:\n\n                  if (status.resize) {\n                    this._kibanaMap.resize();\n                  }\n\n                  if (!(status.params || status.aggs)) {\n                    _context.next = 8;\n                    break;\n                  }\n\n                  _context.next = 8;\n                  return this._updateParams();\n\n                case 8:\n                  if (this.isDataUsable(esResponse)) {\n                    _context.next = 10;\n                    break;\n                  }\n\n                  return _context.abrupt('return');\n\n                case 10:\n                  if (!status.data) {\n                    _context.next = 13;\n                    break;\n                  }\n\n                  _context.next = 13;\n                  return this._updateData(esResponse);\n\n                case 13:\n                  if (status.uiState) {\n                    this._kibanaMap.useUiStateFromVisualization(this.vis);\n                  }\n\n                  _context.next = 16;\n                  return this._whenBaseLayerIsLoaded();\n\n                case 16:\n                case 'end':\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function render(_x, _x2) {\n          return _ref.apply(this, arguments);\n        }\n\n        return render;\n      }()\n\n      /**\n       * Creates an instance of a kibana-map with a single baselayer and assigns it to the this._kibanaMap property.\n       * Clients can override this method to customize the initialization.\n       * @private\n       */\n\n    }, {\n      key: '_makeKibanaMap',\n      value: function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n          var _this = this;\n\n          var options, uiState, zoomFromUiState, centerFromUIState;\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  options = {};\n                  uiState = this.vis.getUiState();\n                  zoomFromUiState = parseInt(uiState.get('mapZoom'));\n                  centerFromUIState = uiState.get('mapCenter');\n\n                  options.zoom = !isNaN(zoomFromUiState) ? zoomFromUiState : this.vis.params.mapZoom;\n                  options.center = centerFromUIState ? centerFromUIState : this.vis.params.mapCenter;\n\n                  this._kibanaMap = new _kibana_map.KibanaMap(this._container, options);\n                  this._kibanaMap.setMinZoom(MINZOOM); //use a default\n                  this._kibanaMap.setMaxZoom(MAXZOOM); //use a default\n\n                  this._kibanaMap.addLegendControl();\n                  this._kibanaMap.addFitControl();\n                  this._kibanaMap.persistUiStateForVisualization(this.vis);\n\n                  this._kibanaMap.on('baseLayer:loaded', function () {\n                    _this._baseLayerDirty = false;\n                  });\n                  this._kibanaMap.on('baseLayer:loading', function () {\n                    _this._baseLayerDirty = true;\n                  });\n                  _context2.next = 16;\n                  return this._updateBaseLayer();\n\n                case 16:\n                case 'end':\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function _makeKibanaMap() {\n          return _ref2.apply(this, arguments);\n        }\n\n        return _makeKibanaMap;\n      }()\n    }, {\n      key: '_baseLayerConfigured',\n      value: function _baseLayerConfigured() {\n        var mapParams = this._getMapsParams();\n        return mapParams.wms.baseLayersAreLoaded || mapParams.wms.selectedTmsLayer;\n      }\n    }, {\n      key: '_updateBaseLayer',\n      value: function () {\n        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n          var mapParams, tmsServices, firstRoadMapLayer, fallback, selectedTmsLayer;\n          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  if (this._kibanaMap) {\n                    _context3.next = 2;\n                    break;\n                  }\n\n                  return _context3.abrupt('return');\n\n                case 2:\n                  mapParams = this._getMapsParams();\n\n                  if (this._baseLayerConfigured()) {\n                    _context3.next = 18;\n                    break;\n                  }\n\n                  _context3.prev = 4;\n                  _context3.next = 7;\n                  return serviceSettings.getTMSServices();\n\n                case 7:\n                  tmsServices = _context3.sent;\n                  firstRoadMapLayer = tmsServices.find(function (s) {\n                    return s.id === 'road_map'; //first road map layer\n                  });\n                  fallback = firstRoadMapLayer ? firstRoadMapLayer : tmsServices[0];\n\n                  if (fallback) {\n                    this._setTmsLayer(firstRoadMapLayer);\n                  }\n                  _context3.next = 17;\n                  break;\n\n                case 13:\n                  _context3.prev = 13;\n                  _context3.t0 = _context3['catch'](4);\n\n                  this._notify.warning(_context3.t0.message);\n                  return _context3.abrupt('return');\n\n                case 17:\n                  return _context3.abrupt('return');\n\n                case 18:\n                  _context3.prev = 18;\n\n                  if (!mapParams.wms.enabled) {\n                    _context3.next = 24;\n                    break;\n                  }\n\n                  if (MINZOOM > this._kibanaMap.getMaxZoomLevel()) {\n                    this._kibanaMap.setMinZoom(MINZOOM);\n                    this._kibanaMap.setMaxZoom(MAXZOOM);\n                  }\n\n                  this._kibanaMap.setBaseLayer({\n                    baseLayerType: 'wms',\n                    options: _extends({\n                      minZoom: MINZOOM,\n                      maxZoom: MAXZOOM,\n                      url: mapParams.wms.url\n                    }, mapParams.wms.options)\n                  });\n                  _context3.next = 28;\n                  break;\n\n                case 24:\n                  _context3.next = 26;\n                  return mapParams.wms.baseLayersAreLoaded;\n\n                case 26:\n                  selectedTmsLayer = mapParams.wms.selectedTmsLayer;\n\n                  this._setTmsLayer(selectedTmsLayer);\n\n                case 28:\n                  _context3.next = 33;\n                  break;\n\n                case 30:\n                  _context3.prev = 30;\n                  _context3.t1 = _context3['catch'](18);\n\n                  this._notify.warning(_context3.t1.message);\n\n                case 33:\n                case 'end':\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this, [[4, 13], [18, 30]]);\n        }));\n\n        function _updateBaseLayer() {\n          return _ref3.apply(this, arguments);\n        }\n\n        return _updateBaseLayer;\n      }()\n    }, {\n      key: '_setTmsLayer',\n      value: function () {\n        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(tmsLayer) {\n          var url, options;\n          return regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  this._kibanaMap.setMinZoom(tmsLayer.minZoom);\n                  this._kibanaMap.setMaxZoom(tmsLayer.maxZoom);\n                  if (this._kibanaMap.getZoomLevel() > tmsLayer.maxZoom) {\n                    this._kibanaMap.setZoomLevel(tmsLayer.maxZoom);\n                  }\n                  url = tmsLayer.url;\n                  options = _lodash2.default.cloneDeep(tmsLayer);\n\n                  delete options.id;\n                  delete options.url;\n                  this._kibanaMap.setBaseLayer({\n                    baseLayerType: 'tms',\n                    options: _extends({ url: url }, options)\n                  });\n\n                case 8:\n                case 'end':\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n\n        function _setTmsLayer(_x3) {\n          return _ref4.apply(this, arguments);\n        }\n\n        return _setTmsLayer;\n      }()\n    }, {\n      key: '_updateData',\n      value: function () {\n        var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n          return regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  throw new Error('Child should implement this method to respond to data-update');\n\n                case 1:\n                case 'end':\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, this);\n        }));\n\n        function _updateData() {\n          return _ref5.apply(this, arguments);\n        }\n\n        return _updateData;\n      }()\n\n      /**\n       * called on options change (vis.params change)\n       */\n\n    }, {\n      key: '_updateParams',\n      value: function () {\n        var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {\n          var mapParams;\n          return regeneratorRuntime.wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  mapParams = this._getMapsParams();\n                  _context6.next = 3;\n                  return this._updateBaseLayer(mapParams);\n\n                case 3:\n                  this._kibanaMap.setLegendPosition(mapParams.legendPosition);\n                  this._kibanaMap.setShowTooltip(mapParams.addTooltip);\n                  this._kibanaMap.useUiStateFromVisualization(this.vis);\n\n                case 6:\n                case 'end':\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, this);\n        }));\n\n        function _updateParams() {\n          return _ref6.apply(this, arguments);\n        }\n\n        return _updateParams;\n      }()\n    }, {\n      key: '_getMapsParams',\n      value: function _getMapsParams() {\n        return _lodash2.default.assign({}, this.vis.type.visConfig.defaults, { type: this.vis.type.name }, this.vis.params);\n      }\n    }, {\n      key: '_whenBaseLayerIsLoaded',\n      value: function _whenBaseLayerIsLoaded() {\n        var _this2 = this;\n\n        if (!this._baseLayerConfigured()) {\n          return true;\n        }\n\n        var maxTimeForBaseLayer = 10000;\n        var interval$ = _Rx.Observable.interval(10).filter(function () {\n          return !_this2._baseLayerDirty;\n        });\n        var timer$ = _Rx.Observable.timer(maxTimeForBaseLayer);\n\n        return _Rx.Observable.race(interval$, timer$).first().toPromise();\n      }\n    }]);\n\n    return BaseMapsVisualization;\n  }();\n}",null]}